// ===== NGUYÊN NHÂN CHÍNH =====

/*
1. BUFFERING DO TRANSPORT POLLING
   - Socket.IO 1.7.4 mặc định dùng polling trước khi upgrade lên websocket
   - Polling có interval delay (thường 25ms-100ms)
   - Messages bị buffer trong polling cycles

2. HEARTBEAT/PING TIMEOUT
   - Client/server tạm thời mất kết nối
   - Messages bị queue cho đến khi reconnect
   - Ping interval mặc định: 25s, timeout: 60s

3. BROWSER TAB THROTTLING
   - Browser throttle inactive tabs
   - Timers bị slow down khi tab không active

4. NETWORK CONGESTION
   - TCP backpressure
   - Packet loss và retransmission

5. EVENT LOOP BLOCKING
   - CPU intensive tasks block event loop
   - Messages bị queue cho đến khi event loop free
*/

// ===== CÁCH DEBUG =====

// 1. Enable Debug Logs
// Server side
process.env.DEBUG = 'socket.io:*';
// Hoặc specific
process.env.DEBUG = 'socket.io:client,socket.io:socket';

// Client side (browser console)
localStorage.debug = 'socket.io-client:*';
// Reload page để apply

// 2. Monitor Connection Events
const io = require('socket.io')(server);

io.on('connection', (socket) => {
    console.log(`[${new Date().toISOString()}] Client connected: ${socket.id}`);
    console.log(`Transport: ${socket.conn.transport.name}`);
    
    // Monitor transport changes
    socket.conn.on('upgrade', () => {
        console.log(`[${new Date().toISOString()}] Upgraded to: ${socket.conn.transport.name}`);
    });
    
    socket.conn.on('upgradeError', (err) => {
        console.log(`[${new Date().toISOString()}] Upgrade error:`, err);
    });
    
    // Monitor ping/pong
    socket.on('ping', () => {
        console.log(`[${new Date().toISOString()}] Ping from ${socket.id}`);
    });
    
    socket.on('pong', (latency) => {
        console.log(`[${new Date().toISOString()}] Pong from ${socket.id}, latency: ${latency}ms`);
    });
    
    // Monitor disconnect
    socket.on('disconnect', (reason) => {
        console.log(`[${new Date().toISOString()}] Client disconnected: ${socket.id}, reason: ${reason}`);
    });
});

// 3. Client Side Debug
const socket = io('http://localhost:3000', {
    // Force websocket để tránh polling
    transports: ['websocket'],
    
    // Reduce ping interval để detect disconnect sớm hơn
    pingInterval: 10000,    // 10s instead of 25s
    pingTimeout: 5000,      // 5s instead of 60s
    
    // Upgrade timeout
    upgradeTimeout: 10000,
    
    // Reconnection settings
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 5
});

// Monitor client events
socket.on('connect', () => {
    console.log(`[${new Date().toISOString()}] Connected`);
    console.log(`Transport: ${socket.io.engine.transport.name}`);
});

socket.on('disconnect', (reason) => {
    console.log(`[${new Date().toISOString()}] Disconnected: ${reason}`);
});

socket.on('reconnect', (attemptNumber) => {
    console.log(`[${new Date().toISOString()}] Reconnected after ${attemptNumber} attempts`);
});

socket.on('reconnect_error', (error) => {
    console.log(`[${new Date().toISOString()}] Reconnect error:`, error);
});

// 4. Message Timing Debug
let messageCount = 0;
let lastMessageTime = Date.now();

socket.on('your-event', (data) => {
    const now = Date.now();
    const gap = now - lastMessageTime;
    messageCount++;
    
    console.log(`[${new Date().toISOString()}] Message #${messageCount}, gap: ${gap}ms`, data);
    
    // Detect buffering (nhiều messages với gap nhỏ sau 1 khoảng trống lớn)
    if (gap > 1000) {
        console.warn(`⚠️ Large gap detected: ${gap}ms`);
    }
    
    lastMessageTime = now;
});

// ===== GIẢI PHÁP =====

// Server Configuration
const io = require('socket.io')(server, {
    // 1. Force websocket transport
    transports: ['websocket'],
    
    // 2. Reduce ping intervals
    pingInterval: 10000,
    pingTimeout: 5000,
    
    // 3. Upgrade immediately
    upgradeTimeout: 10000,
    
    // 4. CORS if needed
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Client Configuration
const socket = io('ws://localhost:3000', {
    // 1. Force websocket
    transports: ['websocket'],
    
    // 2. Reduce timeouts
    timeout: 5000,
    
    // 3. Fast reconnection
    reconnectionDelay: 500,
    reconnectionDelayMax: 2000,
    
    // 4. Force new connection
    forceNew: true
});

// ===== MESSAGE QUEUING SOLUTION =====

// Server: Prevent message buildup
class MessageQueue {
    constructor(socket, maxQueueSize = 100) {
        this.socket = socket;
        this.queue = [];
        this.maxQueueSize = maxQueueSize;
        this.isProcessing = false;
    }
    
    async emit(event, data) {
        // Check if socket is connected
        if (!this.socket.connected) {
            console.warn(`Socket ${this.socket.id} not connected, dropping message`);
            return;
        }
        
        // Prevent queue overflow
        if (this.queue.length >= this.maxQueueSize) {
            console.warn(`Queue full for ${this.socket.id}, dropping oldest message`);
            this.queue.shift();
        }
        
        this.queue.push({ event, data, timestamp: Date.now() });
        
        if (!this.isProcessing) {
            this.processQueue();
        }
    }
    
    async processQueue() {
        this.isProcessing = true;
        
        while (this.queue.length > 0) {
            if (!this.socket.connected) {
                console.warn(`Socket disconnected, stopping queue processing`);
                break;
            }
            
            const message = this.queue.shift();
            const age = Date.now() - message.timestamp;
            
            // Drop old messages
            if (age > 30000) { // 30 seconds
                console.warn(`Dropping old message (age: ${age}ms)`);
                continue;
            }
            
            try {
                this.socket.emit(message.event, message.data);
                // Small delay để tránh overwhelm
                await new Promise(resolve => setTimeout(resolve, 1));
            } catch (error) {
                console.error(`Error emitting message:`, error);
            }
        }
        
        this.isProcessing = false;
    }
}

// Usage
io.on('connection', (socket) => {
    const messageQueue = new MessageQueue(socket);
    
    // Thay vì socket.emit trực tiếp
    messageQueue.emit('data', { message: 'Hello' });
});

// ===== BROWSER TAB VISIBILITY FIX =====

// Client: Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('Tab hidden - socket may be throttled');
    } else {
        console.log('Tab visible - reconnecting if needed');
        if (!socket.connected) {
            socket.connect();
        }
    }
});

// ===== NETWORK MONITORING =====

// Client: Monitor network quality
function monitorNetworkQuality() {
    let pingStart;
    
    socket.on('ping', () => {
        pingStart = Date.now();
    });
    
    socket.on('pong', () => {
        const latency = Date.now() - pingStart;
        console.log(`Network latency: ${latency}ms`);
        
        if (latency > 1000) {
            console.warn('⚠️ High latency detected - possible network issues');
        }
    });
}

monitorNetworkQuality();

// ===== TROUBLESHOOTING CHECKLIST =====

/*
1. Check browser network tab:
   - Xem có requests bị pending không
   - Monitor websocket frames
   - Check cho connection drops

2. Enable debug logs:
   - localStorage.debug = 'socket.io-client:*'
   - process.env.DEBUG = 'socket.io:*'

3. Monitor server resources:
   - CPU usage during message spikes
   - Memory usage
   - Event loop lag

4. Network analysis:
   - Use Wireshark cho packet analysis
   - Check firewall/proxy settings
   - Test different networks

5. Browser specific:
   - Test multiple browsers
   - Check browser console for errors
   - Monitor tab throttling behavior

6. Load testing:
   - Simulate multiple clients
   - Test with high message rates
   - Monitor buffer sizes
*/


# Socket.IO Message Batching - Nguyên nhân và Debug

## 🔍 Các nguyên nhân phổ biến

### 1. **Network Buffering**
- **Nguyên nhân**: TCP/WebSocket buffer tích lũy messages trước khi gửi
- **Triệu chứng**: Messages bị giữ lại 1-2s rồi đổ dồn cùng lúc
- **Phổ biến với**: Kết nối chậm, mobile networks, wifi không ổn định

### 2. **Socket.IO Internal Buffering** 
- **Nguyên nhân**: Socket.IO có cơ chế buffer internal
- **Kích hoạt khi**: 
  - Connection bị disconnect tạm thời
  - Client bận xử lý (blocking operations)
  - Server overload

### 3. **Browser Tab Throttling**
- **Nguyên nhân**: Browser giảm tốc độ tab không active
- **Triệu chứng**: Khi switch tab thì messages đổ dồn
- **Ảnh hưởng**: Chrome, Firefox throttle setTimeout/setInterval

### 4. **Event Loop Blocking**
- **Nguyên nhân**: Client-side JavaScript bị block
- **Nguyên nhân phổ biến**:
  - Heavy DOM manipulation
  - Synchronous operations
  - Large JSON parsing

### 5. **WebSocket Frame Coalescing**
- **Nguyên nhân**: Network infrastructure gộp frames
- **Xảy ra ở**: Proxies, load balancers, CDN

## 🛠️ Debug Steps

### Bước 1: Kiểm tra Network Level

```javascript
// Debug connection quality
socket.on('connect', () => {
  console.log('Connected at:', new Date().toISOString());
  
  // Ping test
  setInterval(() => {
    const start = Date.now();
    socket.emit('ping', start);
  }, 1000);
});

socket.on('pong', (timestamp) => {
  const latency = Date.now() - timestamp;
  console.log('Latency:', latency + 'ms');
  
  if (latency > 500) {
    console.warn('High latency detected');
  }
});
```

### Bước 2: Message Timing Analysis

```javascript
let messageBuffer = [];
let lastMessageTime = 0;

socket.on('your_event', (data) => {
  const now = Date.now();
  const timeSinceLastMessage = now - lastMessageTime;
  
  messageBuffer.push({
    timestamp: now,
    timeDelta: timeSinceLastMessage,
    data: data
  });
  
  // Detect batching pattern
  if (timeSinceLastMessage > 1500) {
    console.warn('Message gap detected:', timeSinceLastMessage + 'ms');
    console.log('Buffered messages:', messageBuffer.length);
  }
  
  lastMessageTime = now;
  
  // Log patterns every 10 messages
  if (messageBuffer.length % 10 === 0) {
    analyzeBatchingPattern();
  }
});

function analyzeBatchingPattern() {
  const gaps = messageBuffer.map(m => m.timeDelta).filter(t => t > 0);
  const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
  const maxGap = Math.max(...gaps);
  
  console.log('Average gap:', avgGap.toFixed(2) + 'ms');
  console.log('Max gap:', maxGap + 'ms');
  console.log('Gaps > 1000ms:', gaps.filter(g => g > 1000).length);
}
```

### Bước 3: Browser Tab Activity Detection

```javascript
let isTabActive = true;
let messagesWhileInactive = 0;

document.addEventListener('visibilitychange', () => {
  const wasActive = isTabActive;
  isTabActive = !document.hidden;
  
  if (!wasActive && isTabActive) {
    console.log('Tab became active, messages received while inactive:', 
                messagesWhileInactive);
    messagesWhileInactive = 0;
  }
});

socket.on('your_event', (data) => {
  if (!isTabActive) {
    messagesWhileInactive++;
  }
  
  console.log('Message received, tab active:', isTabActive);
});
```

### Bước 4: Connection State Monitoring

```javascript
// Track connection state changes
socket.on('connect', () => {
  console.log('✅ Connected');
});

socket.on('disconnect', (reason) => {
  console.log('❌ Disconnected:', reason);
});

socket.on('reconnect', (attemptNumber) => {
  console.log('🔄 Reconnected after', attemptNumber, 'attempts');
});

socket.on('reconnect_attempt', () => {
  console.log('🔄 Attempting to reconnect...');
});

socket.on('connect_error', (error) => {
  console.log('❌ Connection error:', error);
});
```

### Bước 5: Performance Monitoring

```javascript
// Monitor main thread blocking
let lastCheck = performance.now();

function checkEventLoopBlocking() {
  const now = performance.now();
  const delta = now - lastCheck;
  
  if (delta > 50) { // More than 50ms indicates blocking
    console.warn('Event loop blocked for', delta.toFixed(2) + 'ms');
  }
  
  lastCheck = now;
  setTimeout(checkEventLoopBlocking, 10);
}

checkEventLoopBlocking();

// Monitor memory usage
function logMemoryUsage() {
  if (performance.memory) {
    console.log('Memory usage:', {
      used: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + 'MB',
      total: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + 'MB'
    });
  }
}

setInterval(logMemoryUsage, 5000);
```

## 🔧 Giải pháp khắc phục

### 1. Network Level Solutions

```javascript
// Force immediate flush (server-side với Socket.IO 1.7.4)
io.on('connection', (socket) => {
  // Set no delay để tránh Nagle's algorithm
  socket.conn.transport.socket.setNoDelay(true);
  
  // Heartbeat tần suất cao hơn
  socket.conn.pingTimeout = 5000;
  socket.conn.pingInterval = 10000;
});
```

### 2. Client-side Optimizations

```javascript
// Tạo socket với options tối ưu
const socket = io({
  forceNew: true,
  reconnection: true,
  timeout: 5000,
  forceJSONP: false,
  autoConnect: true,
  transports: ['websocket', 'polling'] // Ưu tiên websocket
});

// Xử lý messages không blocking
socket.on('your_event', (data) => {
  // Sử dụng requestAnimationFrame hoặc setTimeout để tránh blocking
  requestAnimationFrame(() => {
    processMessage(data);
  });
});

function processMessage(data) {
  // Process message without blocking event loop
  // Chia nhỏ heavy operations
}
```

### 3. Server-side Improvements

```javascript
// Server optimization
const io = require('socket.io')(server, {
  pingTimeout: 5000,
  pingInterval: 10000,
  upgradeTimeout: 3000,
  allowUpgrades: true,
  cookie: false,
  serveClient: false,
  // Disable compression để giảm latency
  compression: false,
  // Tăng buffer size nếu cần
  maxHttpBufferSize: 1e6
});
```

## 📊 Monitoring Dashboard

```javascript
// Tạo dashboard đơn giản để theo dõi
class SocketMonitor {
  constructor() {
    this.stats = {
      messagesReceived: 0,
      averageLatency: 0,
      maxLatency: 0,
      batchCount: 0,
      connectionDrops: 0
    };
    
    this.createDashboard();
  }
  
  createDashboard() {
    const dashboard = document.createElement('div');
    dashboard.style.cssText = `
      position: fixed; top: 10px; right: 10px;
      background: rgba(0,0,0,0.8); color: white;
      padding: 10px; border-radius: 5px;
      font-family: monospace; font-size: 12px;
      z-index: 9999;
    `;
    dashboard.id = 'socket-monitor';
    document.body.appendChild(dashboard);
    
    setInterval(() => this.updateDashboard(), 1000);
  }
  
  updateDashboard() {
    const dashboard = document.getElementById('socket-monitor');
    dashboard.innerHTML = `
      Messages: ${this.stats.messagesReceived}<br>
      Avg Latency: ${this.stats.averageLatency}ms<br>
      Max Latency: ${this.stats.maxLatency}ms<br>
      Batches: ${this.stats.batchCount}<br>
      Drops: ${this.stats.connectionDrops}
    `;
  }
  
  recordMessage(latency) {
    this.stats.messagesReceived++;
    this.stats.averageLatency = 
      (this.stats.averageLatency + latency) / 2;
    this.stats.maxLatency = 
      Math.max(this.stats.maxLatency, latency);
  }
}

const monitor = new SocketMonitor();
```

## ⚡ Quick Debug Checklist

1. **Kiểm tra Browser DevTools**
   - Network tab → WebSocket frames
   - Performance tab → Main thread activity
   - Memory tab → Heap size

2. **Test kết nối**
   - Ping/pong latency
   - Connection stability
   - Mobile vs Desktop

3. **Code review**
   - Event handlers có blocking không?
   - Message processing có heavy operations?
   - DOM manipulation có tối ưu?

4. **Infrastructure**
   - Proxy/Load balancer settings
   - Network quality
   - Server resources

5. **Monitoring tools**
   - Network monitoring
   - Application performance monitoring
   - Real-time dashboards