// ===== NGUY√äN NH√ÇN CH√çNH =====

/*
1. BUFFERING DO TRANSPORT POLLING
   - Socket.IO 1.7.4 m·∫∑c ƒë·ªãnh d√πng polling tr∆∞·ªõc khi upgrade l√™n websocket
   - Polling c√≥ interval delay (th∆∞·ªùng 25ms-100ms)
   - Messages b·ªã buffer trong polling cycles

2. HEARTBEAT/PING TIMEOUT
   - Client/server t·∫°m th·ªùi m·∫•t k·∫øt n·ªëi
   - Messages b·ªã queue cho ƒë·∫øn khi reconnect
   - Ping interval m·∫∑c ƒë·ªãnh: 25s, timeout: 60s

3. BROWSER TAB THROTTLING
   - Browser throttle inactive tabs
   - Timers b·ªã slow down khi tab kh√¥ng active

4. NETWORK CONGESTION
   - TCP backpressure
   - Packet loss v√† retransmission

5. EVENT LOOP BLOCKING
   - CPU intensive tasks block event loop
   - Messages b·ªã queue cho ƒë·∫øn khi event loop free
*/

// ===== C√ÅCH DEBUG =====

// 1. Enable Debug Logs
// Server side
process.env.DEBUG = 'socket.io:*';
// Ho·∫∑c specific
process.env.DEBUG = 'socket.io:client,socket.io:socket';

// Client side (browser console)
localStorage.debug = 'socket.io-client:*';
// Reload page ƒë·ªÉ apply

// 2. Monitor Connection Events
const io = require('socket.io')(server);

io.on('connection', (socket) => {
    console.log(`[${new Date().toISOString()}] Client connected: ${socket.id}`);
    console.log(`Transport: ${socket.conn.transport.name}`);
    
    // Monitor transport changes
    socket.conn.on('upgrade', () => {
        console.log(`[${new Date().toISOString()}] Upgraded to: ${socket.conn.transport.name}`);
    });
    
    socket.conn.on('upgradeError', (err) => {
        console.log(`[${new Date().toISOString()}] Upgrade error:`, err);
    });
    
    // Monitor ping/pong
    socket.on('ping', () => {
        console.log(`[${new Date().toISOString()}] Ping from ${socket.id}`);
    });
    
    socket.on('pong', (latency) => {
        console.log(`[${new Date().toISOString()}] Pong from ${socket.id}, latency: ${latency}ms`);
    });
    
    // Monitor disconnect
    socket.on('disconnect', (reason) => {
        console.log(`[${new Date().toISOString()}] Client disconnected: ${socket.id}, reason: ${reason}`);
    });
});

// 3. Client Side Debug
const socket = io('http://localhost:3000', {
    // Force websocket ƒë·ªÉ tr√°nh polling
    transports: ['websocket'],
    
    // Reduce ping interval ƒë·ªÉ detect disconnect s·ªõm h∆°n
    pingInterval: 10000,    // 10s instead of 25s
    pingTimeout: 5000,      // 5s instead of 60s
    
    // Upgrade timeout
    upgradeTimeout: 10000,
    
    // Reconnection settings
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 5
});

// Monitor client events
socket.on('connect', () => {
    console.log(`[${new Date().toISOString()}] Connected`);
    console.log(`Transport: ${socket.io.engine.transport.name}`);
});

socket.on('disconnect', (reason) => {
    console.log(`[${new Date().toISOString()}] Disconnected: ${reason}`);
});

socket.on('reconnect', (attemptNumber) => {
    console.log(`[${new Date().toISOString()}] Reconnected after ${attemptNumber} attempts`);
});

socket.on('reconnect_error', (error) => {
    console.log(`[${new Date().toISOString()}] Reconnect error:`, error);
});

// 4. Message Timing Debug
let messageCount = 0;
let lastMessageTime = Date.now();

socket.on('your-event', (data) => {
    const now = Date.now();
    const gap = now - lastMessageTime;
    messageCount++;
    
    console.log(`[${new Date().toISOString()}] Message #${messageCount}, gap: ${gap}ms`, data);
    
    // Detect buffering (nhi·ªÅu messages v·ªõi gap nh·ªè sau 1 kho·∫£ng tr·ªëng l·ªõn)
    if (gap > 1000) {
        console.warn(`‚ö†Ô∏è Large gap detected: ${gap}ms`);
    }
    
    lastMessageTime = now;
});

// ===== GI·∫¢I PH√ÅP =====

// Server Configuration
const io = require('socket.io')(server, {
    // 1. Force websocket transport
    transports: ['websocket'],
    
    // 2. Reduce ping intervals
    pingInterval: 10000,
    pingTimeout: 5000,
    
    // 3. Upgrade immediately
    upgradeTimeout: 10000,
    
    // 4. CORS if needed
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

// Client Configuration
const socket = io('ws://localhost:3000', {
    // 1. Force websocket
    transports: ['websocket'],
    
    // 2. Reduce timeouts
    timeout: 5000,
    
    // 3. Fast reconnection
    reconnectionDelay: 500,
    reconnectionDelayMax: 2000,
    
    // 4. Force new connection
    forceNew: true
});

// ===== MESSAGE QUEUING SOLUTION =====

// Server: Prevent message buildup
class MessageQueue {
    constructor(socket, maxQueueSize = 100) {
        this.socket = socket;
        this.queue = [];
        this.maxQueueSize = maxQueueSize;
        this.isProcessing = false;
    }
    
    async emit(event, data) {
        // Check if socket is connected
        if (!this.socket.connected) {
            console.warn(`Socket ${this.socket.id} not connected, dropping message`);
            return;
        }
        
        // Prevent queue overflow
        if (this.queue.length >= this.maxQueueSize) {
            console.warn(`Queue full for ${this.socket.id}, dropping oldest message`);
            this.queue.shift();
        }
        
        this.queue.push({ event, data, timestamp: Date.now() });
        
        if (!this.isProcessing) {
            this.processQueue();
        }
    }
    
    async processQueue() {
        this.isProcessing = true;
        
        while (this.queue.length > 0) {
            if (!this.socket.connected) {
                console.warn(`Socket disconnected, stopping queue processing`);
                break;
            }
            
            const message = this.queue.shift();
            const age = Date.now() - message.timestamp;
            
            // Drop old messages
            if (age > 30000) { // 30 seconds
                console.warn(`Dropping old message (age: ${age}ms)`);
                continue;
            }
            
            try {
                this.socket.emit(message.event, message.data);
                // Small delay ƒë·ªÉ tr√°nh overwhelm
                await new Promise(resolve => setTimeout(resolve, 1));
            } catch (error) {
                console.error(`Error emitting message:`, error);
            }
        }
        
        this.isProcessing = false;
    }
}

// Usage
io.on('connection', (socket) => {
    const messageQueue = new MessageQueue(socket);
    
    // Thay v√¨ socket.emit tr·ª±c ti·∫øp
    messageQueue.emit('data', { message: 'Hello' });
});

// ===== BROWSER TAB VISIBILITY FIX =====

// Client: Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        console.log('Tab hidden - socket may be throttled');
    } else {
        console.log('Tab visible - reconnecting if needed');
        if (!socket.connected) {
            socket.connect();
        }
    }
});

// ===== NETWORK MONITORING =====

// Client: Monitor network quality
function monitorNetworkQuality() {
    let pingStart;
    
    socket.on('ping', () => {
        pingStart = Date.now();
    });
    
    socket.on('pong', () => {
        const latency = Date.now() - pingStart;
        console.log(`Network latency: ${latency}ms`);
        
        if (latency > 1000) {
            console.warn('‚ö†Ô∏è High latency detected - possible network issues');
        }
    });
}

monitorNetworkQuality();

// ===== TROUBLESHOOTING CHECKLIST =====

/*
1. Check browser network tab:
   - Xem c√≥ requests b·ªã pending kh√¥ng
   - Monitor websocket frames
   - Check cho connection drops

2. Enable debug logs:
   - localStorage.debug = 'socket.io-client:*'
   - process.env.DEBUG = 'socket.io:*'

3. Monitor server resources:
   - CPU usage during message spikes
   - Memory usage
   - Event loop lag

4. Network analysis:
   - Use Wireshark cho packet analysis
   - Check firewall/proxy settings
   - Test different networks

5. Browser specific:
   - Test multiple browsers
   - Check browser console for errors
   - Monitor tab throttling behavior

6. Load testing:
   - Simulate multiple clients
   - Test with high message rates
   - Monitor buffer sizes
*/


# Socket.IO Message Batching - Nguy√™n nh√¢n v√† Debug

## üîç C√°c nguy√™n nh√¢n ph·ªï bi·∫øn

### 1. **Network Buffering**
- **Nguy√™n nh√¢n**: TCP/WebSocket buffer t√≠ch l≈©y messages tr∆∞·ªõc khi g·ª≠i
- **Tri·ªáu ch·ª©ng**: Messages b·ªã gi·ªØ l·∫°i 1-2s r·ªìi ƒë·ªï d·ªìn c√πng l√∫c
- **Ph·ªï bi·∫øn v·ªõi**: K·∫øt n·ªëi ch·∫≠m, mobile networks, wifi kh√¥ng ·ªïn ƒë·ªãnh

### 2. **Socket.IO Internal Buffering** 
- **Nguy√™n nh√¢n**: Socket.IO c√≥ c∆° ch·∫ø buffer internal
- **K√≠ch ho·∫°t khi**: 
  - Connection b·ªã disconnect t·∫°m th·ªùi
  - Client b·∫≠n x·ª≠ l√Ω (blocking operations)
  - Server overload

### 3. **Browser Tab Throttling**
- **Nguy√™n nh√¢n**: Browser gi·∫£m t·ªëc ƒë·ªô tab kh√¥ng active
- **Tri·ªáu ch·ª©ng**: Khi switch tab th√¨ messages ƒë·ªï d·ªìn
- **·∫¢nh h∆∞·ªüng**: Chrome, Firefox throttle setTimeout/setInterval

### 4. **Event Loop Blocking**
- **Nguy√™n nh√¢n**: Client-side JavaScript b·ªã block
- **Nguy√™n nh√¢n ph·ªï bi·∫øn**:
  - Heavy DOM manipulation
  - Synchronous operations
  - Large JSON parsing

### 5. **WebSocket Frame Coalescing**
- **Nguy√™n nh√¢n**: Network infrastructure g·ªôp frames
- **X·∫£y ra ·ªü**: Proxies, load balancers, CDN

## üõ†Ô∏è Debug Steps

### B∆∞·ªõc 1: Ki·ªÉm tra Network Level

```javascript
// Debug connection quality
socket.on('connect', () => {
  console.log('Connected at:', new Date().toISOString());
  
  // Ping test
  setInterval(() => {
    const start = Date.now();
    socket.emit('ping', start);
  }, 1000);
});

socket.on('pong', (timestamp) => {
  const latency = Date.now() - timestamp;
  console.log('Latency:', latency + 'ms');
  
  if (latency > 500) {
    console.warn('High latency detected');
  }
});
```

### B∆∞·ªõc 2: Message Timing Analysis

```javascript
let messageBuffer = [];
let lastMessageTime = 0;

socket.on('your_event', (data) => {
  const now = Date.now();
  const timeSinceLastMessage = now - lastMessageTime;
  
  messageBuffer.push({
    timestamp: now,
    timeDelta: timeSinceLastMessage,
    data: data
  });
  
  // Detect batching pattern
  if (timeSinceLastMessage > 1500) {
    console.warn('Message gap detected:', timeSinceLastMessage + 'ms');
    console.log('Buffered messages:', messageBuffer.length);
  }
  
  lastMessageTime = now;
  
  // Log patterns every 10 messages
  if (messageBuffer.length % 10 === 0) {
    analyzeBatchingPattern();
  }
});

function analyzeBatchingPattern() {
  const gaps = messageBuffer.map(m => m.timeDelta).filter(t => t > 0);
  const avgGap = gaps.reduce((a, b) => a + b, 0) / gaps.length;
  const maxGap = Math.max(...gaps);
  
  console.log('Average gap:', avgGap.toFixed(2) + 'ms');
  console.log('Max gap:', maxGap + 'ms');
  console.log('Gaps > 1000ms:', gaps.filter(g => g > 1000).length);
}
```

### B∆∞·ªõc 3: Browser Tab Activity Detection

```javascript
let isTabActive = true;
let messagesWhileInactive = 0;

document.addEventListener('visibilitychange', () => {
  const wasActive = isTabActive;
  isTabActive = !document.hidden;
  
  if (!wasActive && isTabActive) {
    console.log('Tab became active, messages received while inactive:', 
                messagesWhileInactive);
    messagesWhileInactive = 0;
  }
});

socket.on('your_event', (data) => {
  if (!isTabActive) {
    messagesWhileInactive++;
  }
  
  console.log('Message received, tab active:', isTabActive);
});
```

### B∆∞·ªõc 4: Connection State Monitoring

```javascript
// Track connection state changes
socket.on('connect', () => {
  console.log('‚úÖ Connected');
});

socket.on('disconnect', (reason) => {
  console.log('‚ùå Disconnected:', reason);
});

socket.on('reconnect', (attemptNumber) => {
  console.log('üîÑ Reconnected after', attemptNumber, 'attempts');
});

socket.on('reconnect_attempt', () => {
  console.log('üîÑ Attempting to reconnect...');
});

socket.on('connect_error', (error) => {
  console.log('‚ùå Connection error:', error);
});
```

### B∆∞·ªõc 5: Performance Monitoring

```javascript
// Monitor main thread blocking
let lastCheck = performance.now();

function checkEventLoopBlocking() {
  const now = performance.now();
  const delta = now - lastCheck;
  
  if (delta > 50) { // More than 50ms indicates blocking
    console.warn('Event loop blocked for', delta.toFixed(2) + 'ms');
  }
  
  lastCheck = now;
  setTimeout(checkEventLoopBlocking, 10);
}

checkEventLoopBlocking();

// Monitor memory usage
function logMemoryUsage() {
  if (performance.memory) {
    console.log('Memory usage:', {
      used: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + 'MB',
      total: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + 'MB'
    });
  }
}

setInterval(logMemoryUsage, 5000);
```

## üîß Gi·∫£i ph√°p kh·∫Øc ph·ª•c

### 1. Network Level Solutions

```javascript
// Force immediate flush (server-side v·ªõi Socket.IO 1.7.4)
io.on('connection', (socket) => {
  // Set no delay ƒë·ªÉ tr√°nh Nagle's algorithm
  socket.conn.transport.socket.setNoDelay(true);
  
  // Heartbeat t·∫ßn su·∫•t cao h∆°n
  socket.conn.pingTimeout = 5000;
  socket.conn.pingInterval = 10000;
});
```

### 2. Client-side Optimizations

```javascript
// T·∫°o socket v·ªõi options t·ªëi ∆∞u
const socket = io({
  forceNew: true,
  reconnection: true,
  timeout: 5000,
  forceJSONP: false,
  autoConnect: true,
  transports: ['websocket', 'polling'] // ∆Øu ti√™n websocket
});

// X·ª≠ l√Ω messages kh√¥ng blocking
socket.on('your_event', (data) => {
  // S·ª≠ d·ª•ng requestAnimationFrame ho·∫∑c setTimeout ƒë·ªÉ tr√°nh blocking
  requestAnimationFrame(() => {
    processMessage(data);
  });
});

function processMessage(data) {
  // Process message without blocking event loop
  // Chia nh·ªè heavy operations
}
```

### 3. Server-side Improvements

```javascript
// Server optimization
const io = require('socket.io')(server, {
  pingTimeout: 5000,
  pingInterval: 10000,
  upgradeTimeout: 3000,
  allowUpgrades: true,
  cookie: false,
  serveClient: false,
  // Disable compression ƒë·ªÉ gi·∫£m latency
  compression: false,
  // TƒÉng buffer size n·∫øu c·∫ßn
  maxHttpBufferSize: 1e6
});
```

## üìä Monitoring Dashboard

```javascript
// T·∫°o dashboard ƒë∆°n gi·∫£n ƒë·ªÉ theo d√µi
class SocketMonitor {
  constructor() {
    this.stats = {
      messagesReceived: 0,
      averageLatency: 0,
      maxLatency: 0,
      batchCount: 0,
      connectionDrops: 0
    };
    
    this.createDashboard();
  }
  
  createDashboard() {
    const dashboard = document.createElement('div');
    dashboard.style.cssText = `
      position: fixed; top: 10px; right: 10px;
      background: rgba(0,0,0,0.8); color: white;
      padding: 10px; border-radius: 5px;
      font-family: monospace; font-size: 12px;
      z-index: 9999;
    `;
    dashboard.id = 'socket-monitor';
    document.body.appendChild(dashboard);
    
    setInterval(() => this.updateDashboard(), 1000);
  }
  
  updateDashboard() {
    const dashboard = document.getElementById('socket-monitor');
    dashboard.innerHTML = `
      Messages: ${this.stats.messagesReceived}<br>
      Avg Latency: ${this.stats.averageLatency}ms<br>
      Max Latency: ${this.stats.maxLatency}ms<br>
      Batches: ${this.stats.batchCount}<br>
      Drops: ${this.stats.connectionDrops}
    `;
  }
  
  recordMessage(latency) {
    this.stats.messagesReceived++;
    this.stats.averageLatency = 
      (this.stats.averageLatency + latency) / 2;
    this.stats.maxLatency = 
      Math.max(this.stats.maxLatency, latency);
  }
}

const monitor = new SocketMonitor();
```

## ‚ö° Quick Debug Checklist

1. **Ki·ªÉm tra Browser DevTools**
   - Network tab ‚Üí WebSocket frames
   - Performance tab ‚Üí Main thread activity
   - Memory tab ‚Üí Heap size

2. **Test k·∫øt n·ªëi**
   - Ping/pong latency
   - Connection stability
   - Mobile vs Desktop

3. **Code review**
   - Event handlers c√≥ blocking kh√¥ng?
   - Message processing c√≥ heavy operations?
   - DOM manipulation c√≥ t·ªëi ∆∞u?

4. **Infrastructure**
   - Proxy/Load balancer settings
   - Network quality
   - Server resources

5. **Monitoring tools**
   - Network monitoring
   - Application performance monitoring
   - Real-time dashboards